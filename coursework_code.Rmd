---
title: | 
  | R Markdown template 
  | MSc in Statistics, Imperial College London
author: 'YOUR CID'
subtitle: ""
output:
  bookdown::pdf_book:
    keep_tex: yes
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    highlight: tango
  html_document:
    toc: yes
    df_print: paged
bibliography: ["2025-26_MSc_Statistics_coursework_Rmarkdown_template.bib"]
link-citations: true
---

```{=html}
<style type="text/css">
h1{
  font-size: 24pt;
}
h2{
  font-size: 18pt;
}
body{
  font-size: 12pt;
}
</style>
```

```{r setup, include = FALSE, tidy=TRUE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
include_solutions <- TRUE
```

```{r setup2, include=FALSE, tidy=TRUE}
require(rmarkdown)
require(knitr)
require(kableExtra)
# Put any library imports and other preamble here.
```

This Rmarkdown document is intended to provide a basic template that you may use throughout the course, and to introduce you to basic functionality of the open-source bookdown R package for writing Rmarkdown documents [@xie2016bookdown].

Please note:

-   Rmarkdown syntax for the title and document style;
-   bookdown syntax to label and reference equations;
-   bookdown syntax to referencing literate and provide a bib file;
-   kable syntax to build clean and clear tables that can be referenced;
-   Rmarkdown inline functions to collect and print all code used.

# Question 1

Some over-arching comments...

**Part a.**\

```{r, echo=FALSE}

### Question 1a
library(coda)

target <- function(x) {
  if (x>=2){
    return (exp(-3*(x-2)) + exp(-(x-30)^2) + exp(-((x-20)^2)/0.01))
  }
  else{
    return (0)
  }
}

t=seq(0,50, length.out=1000)
plot(t, sapply(t, function(t) target(t)), type="l", xlab="x", ylab = "f(x)")

MetrHastw <- function(X0, sigmaprop, nsteps, f){
  X <- numeric(nsteps+1) 
  X[1] <- X0
  for (i in 2:(nsteps+1)){
    Y <- rnorm(1, mean=X[i-1],sd=sigmaprop)
    if (log(runif(1))<=min(log(f(Y))-log(f(X[i-1])),1)){
      X[i] <- Y}
    else{ X[i] <- X[i-1]}
   }
 X
} 

#seems larger variance is better when we have 10,000 samples for mixing. All chains converge pretty fast, it's just the different modes that make this distribution difficult.

#Gelman-Rubin is probably unnecessary here since we can see the different modes visually

X0s <- c(2, 5, 10, 15, 20, 25, 30, 35, 40)
chains1 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=1, nsteps=10000, f=target)))
traceplot(chains1) #maybe some labels would be nice. Particularly that the variance here is 1.

chains2 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=2, nsteps=10000, f=target)))
traceplot(chains2)

chains3 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=3, nsteps=10000, f=target)))
traceplot(chains3)

chains4 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=5, nsteps=10000, f=target)))
traceplot(chains4) #actually ends up completely missing the mass around x=20

chains5 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=8, nsteps=10000, f=target)))
traceplot(chains5) 

chains6 <- lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=11, nsteps=10000, f=target)))
traceplot(chains6) 

X0s2 <- c(10)

chains_large <- lapply(X0s2, function(x0) mcmc(MetrHastw(x0, sigmaprop=20, nsteps=10000, f=target)))
traceplot(chains_large) #it seems all of them cover the space but it's hard to see if they find that mode at 20 since they move around so much. Might be easier to focus on fewer chains for this

```

**Part b.**\
Your solution begins here.

```{r echo=FALSE}

### Question 1b

MH_newprop <- function(X0, sigmaprop, nsteps, f){
  X <- numeric(nsteps+1) 
  X[1] <- X0
  newprop <- function(mean, sd){
    proposal <- rnorm(1, mean=mean, sd=sd)
    if (proposal>=2){
      return (proposal)
    }
    else{
      return (2)
    }
  }
  for (i in 2:(nsteps+1)){
    Y <- newprop(mean=X[i-1], sd=sigmaprop)
    if (log(runif(1))<=min(log(f(Y))-log(f(X[i-1])),1)){
      X[i] <- Y}
    else{ X[i] <- X[i-1]}
   }
 X
} 

X0sb <- c(15)

chains_b <- lapply(X0sb, function(x0) mcmc(MH_newprop(x0, sigmaprop=11, nsteps=10000, f=target)))
traceplot(chains_b) #seems it worked?


```

**Part c.**\
Your solution begins here.

```{r echo=FALSE}

### Question 1c
# INSERT CODE
```

# Code appendix

Rather than re-paste all the code to the appendix, here is a trick which makes the markdown file output all the code (without execution) in the appendix, without any duplication.

Please keep in mind to format the code so that the entire code is clearly visible and does not run into the margins of the pdf version.

```{r ref.label=knitr::all_labels(), echo = T, eval = F}
```

# References
