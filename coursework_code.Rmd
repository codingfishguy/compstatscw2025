---
title: | 
  | R Markdown template 
  | MSc in Statistics, Imperial College London
author: 'YOUR CID'
subtitle: ""
output:
  bookdown::pdf_book:
    keep_tex: yes
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    highlight: tango
  html_document:
    toc: yes
    df_print: paged
bibliography: ["2025-26_MSc_Statistics_coursework_Rmarkdown_template.bib"]
link-citations: true
---

```{=html}
<style type="text/css">
h1{
  font-size: 24pt;
}
h2{
  font-size: 18pt;
}
body{
  font-size: 12pt;
}
</style>
```

```{r setup, include = FALSE, tidy=TRUE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
include_solutions <- TRUE
```

```{r setup2, include=FALSE, tidy=TRUE}
require(rmarkdown)
require(knitr)
require(kableExtra)
# Put any library imports and other preamble here.
```

This Rmarkdown document is intended to provide a basic template that you may use throughout the course, and to introduce you to basic functionality of the open-source bookdown R package for writing Rmarkdown documents [@xie2016bookdown].

Please note:

-   Rmarkdown syntax for the title and document style;
-   bookdown syntax to label and reference equations;
-   bookdown syntax to referencing literate and provide a bib file;
-   kable syntax to build clean and clear tables that can be referenced;
-   Rmarkdown inline functions to collect and print all code used.

Probably should include a statement of originality here:

# Question 1

Some over-arching comments...

**Part a.**\

```{r, echo=FALSE}

### Question 1a
library(coda)

target <- function(x) {
  if (x>=2){
    return (exp(-3*(x-2)) + exp(-(x-30)^2) + exp(-((x-20)^2)/0.01))
  }
  else{
    return (0)
  }
}

t=seq(0,50, length.out=1000)
plot(t, sapply(t, function(t) target(t)), type="l", xlab="x", ylab = "f(x)")

MetrHastw <- function(X0, sigmaprop, nsteps, f){
  X <- numeric(nsteps+1) 
  X[1] <- X0
  for (i in 2:(nsteps+1)){
    Y <- rnorm(1, mean=X[i-1],sd=sigmaprop)
    if (log(runif(1)) <= log(f(Y)) -log(f(X[i-1]))){
      X[i] <- Y}
    else{ X[i] <- X[i-1]}
   }
 X
} 

#seems larger variance is better when we have 10,000 samples for mixing. All chains converge pretty fast, it's just the different modes that make this distribution difficult.

#I should also compute the Gelman Rubin statistic for each chain as a quantitative way to display convergence or lack thereof

X0s <- c(2, 5, 10, 15, 20, 25, 30, 35, 40)
chains1 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=1, nsteps=10000, f=target)))
traceplot(chains1) #maybe some labels would be nice. Particularly that the variance here is 1.

chains2 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=2, nsteps=10000, f=target)))
traceplot(chains2)

chains3 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=3, nsteps=10000, f=target)))
traceplot(chains3)

chains4 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=5, nsteps=10000, f=target)))
traceplot(chains4) #actually ends up completely missing the mass around x=20

chains5 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=8, nsteps=10000, f=target)))
traceplot(chains5) 

chains6 <- lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=11, nsteps=10000, f=target)))
traceplot(chains6) 

X0s2 <- c(10)

chains_large <- lapply(X0s2, function(x0) mcmc(MetrHastw(x0, sigmaprop=20, nsteps=10000, f=target)))
traceplot(chains_large) #it seems all of them cover the space but it's hard to see if they find that mode at 20 since they move around so much. Might be easier to focus on fewer chains for this

```

**Part b.**\
Your solution begins here.

```{r echo=FALSE}

### Question 1b

#Idea: could use an independence sampler

target <- function(x) {
  if (x>=2){
    return (exp(-3*(x-2)) + exp(-(x-30)^2) + exp(-((x-20)^2)/0.01))
  }
  else{
    return (0)
  }
}


MH_newprop <- function(X0, nsteps, f){
  X <- numeric(nsteps+1) 
  X[1] <- X0
  
  for (i in 2:(nsteps+1)){
    Y <- runif(1, min=2, max=45)
    log_acc <- log(f(Y)) - log(f(X[i-1])) #the proposal densities cancel out as they are the same everywhere 
    
    if (log(runif(1)) <= log_acc){
      X[i] <- Y
    }
    else{X[i] <- X[i-1]}
   }
 X
} 

X0sb <- c(5,15,25)

chains_b <- lapply(X0sb, function(x0) mcmc(MH_newprop(x0, nsteps=10000, f=target)))
traceplot(chains_b)


```

**Part c.**\
Your solution begins here.

```{r echo=FALSE}
### Question 1c

paralleltemp <- function(num.steps, Ts, sigmas) { #should probably add a target to this distribution
  M <- length(Ts)
  samples <- matrix(NA, nrow = num.steps, ncol=M)
  
  X <- rep(0, M)
  
  for (n in 1:num.steps) {
      # we are going to do a x-step
      for (m in 1:M) {
        y <- X[m] + sigmas[m]*rnorm(1)
        alpha <- g(y)^(1/Ts[m]) / g(X[m])^(1/Ts[m]) #where does this come from in the algorithm???
        
        if (runif(1) <= alpha) {
          X[m] <- y
        }
      }
      ### we are going for a swap
      m <- sample(1:(M-1), 1)
      
      num = (g(X[m])^(1/Ts[m+1])*g(X[m+1])^(1/Ts[m]))
      denom = (g(X[m])^(1/Ts[m])*g(X[m+1])^(1/Ts[m+1]))
      
      if (runif(1) <= num/denom) {
        X[c(m, m+1)] = X[c(m+1, m)]
      }
    
    samples[n, ] = X
  }
  
  return(samples)
}



```

# Code appendix

Rather than re-paste all the code to the appendix, here is a trick which makes the markdown file output all the code (without execution) in the appendix, without any duplication.

Please keep in mind to format the code so that the entire code is clearly visible and does not run into the margins of the pdf version.

```{r ref.label=knitr::all_labels(), echo = T, eval = F}
```

# References
