---
title: "| R Markdown template \n| MSc in Statistics, Imperial College London\n"
author: "YOUR CID"
subtitle: ''
output:
  bookdown::pdf_book:
    keep_tex: true
  bookdown::pdf_document2:
    toc: true
    toc_float: true
    highlight: tango
  html_document:
    toc: true
    df_print: paged
link-citations: true
---

```{=html}
<style type="text/css">
h1{
  font-size: 24pt;
}
h2{
  font-size: 18pt;
}
body{
  font-size: 12pt;
}
</style>
```

```{r setup, include = FALSE, tidy=TRUE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
include_solutions <- TRUE
```

```{r setup2, include=FALSE, tidy=TRUE}
require(rmarkdown)
require(knitr)
require(kableExtra)
require(formatR)
# Put any library imports and other preamble here.
```

This Rmarkdown document is intended to provide a basic template that you may use throughout the course, and to introduce you to basic functionality of the open-source bookdown R package for writing Rmarkdown documents [@xie2016bookdown].

Please note:

-   Rmarkdown syntax for the title and document style;
-   bookdown syntax to label and reference equations;
-   bookdown syntax to referencing literate and provide a bib file;
-   kable syntax to build clean and clear tables that can be referenced;
-   Rmarkdown inline functions to collect and print all code used.

I, 06051710, certify that this assessed coursework is my own work, unless otherwise acknowledged, and includes no plagiarism. I have not discussed my coursework with anyone else except when seeking clarification with the module lecturer via email or on MS Teams. I have not shared any code underlying my coursework with anyone else prior to submission.

# Question 1

**Part a.**\
I implemented the standard version of the Random Walk Metropolis Hastings algorithm. The first thing I did, mainly so that I could get a better idea of where to initialise my chain from, was plot the target distribution. See Figure 1 below.

```{r fig-q1a1, echo=FALSE, fig.cap="Target function up to proportionality"}
set.seed(17)
#could add a histogram here

### Question 1a
library(coda)

target <- function(x) {
  if (x>=2){
    return (exp(-3*(x-2)) + exp(-(x-30)^2) + exp(-((x-20)^2)/0.01))
  }
  else{
    return (0)
  }
}

t=seq(0,50, length.out=1000)
plot(t, sapply(t, function(t) target(t)), type="l", xlab="x", ylab = "f(x)")
```

After this, I ran the random walk metropolis hastings with sigma of 1,2,3,5,8,11 and 20 and plotted the traceplots for each chain. As can be seen,

```{r fig-q1a2, echo=FALSE, fig.cap="Traceplots for different variances in the RWMH algorithm"}
MetrHastw <- function(X0, sigmaprop, nsteps, f){
  X <- numeric(nsteps+1) 
  X[1] <- X0
  for (i in 2:(nsteps+1)){
    Y <- rnorm(1, mean=X[i-1],sd=sigmaprop)
    if (log(runif(1)) <= log(f(Y)) -log(f(X[i-1]))){
      X[i] <- Y}
    else{ X[i] <- X[i-1]}
   }
 X
} 

#seems larger variance is better when we have 10,000 samples for mixing. All chains converge pretty fast, it's just the different modes that make this distribution difficult.

#I should also compute the Gelman Rubin statistic for each chain as a quantitative way to display convergence or lack thereof
#Also group all the plots in one figure

X0s <- c(2, 5, 10, 15, 20, 25, 30, 35, 40)
chains1 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=1, nsteps=10000, f=target)))
chains2 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=2, nsteps=10000, f=target)))
chains3 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=3, nsteps=10000, f=target)))
chains4 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=5, nsteps=10000, f=target)))#actually ends up completely missing the mass around x=20
chains5 <-lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=8, nsteps=10000, f=target)))
chains6 <- lapply(X0s, function(x0) mcmc(MetrHastw(x0, sigmaprop=11, nsteps=10000, f=target)))

par(mfrow=c(2,3))  

traceplot(chains1); title("σ = 1")
traceplot(chains2); title("σ = 2")
traceplot(chains3); title("σ = 3")
traceplot(chains4); title("σ = 5")
traceplot(chains5); title("σ = 8")
traceplot(chains6); title("σ = 11")

```

**Part b.**\
Your solution begins here.

```{r echo=FALSE}

### Question 1b

#should probably add a histogram here

target <- function(x) {
  if (x>=2){
    return (exp(-3*(x-2)) + exp(-(x-30)^2) + exp(-((x-20)^2)/0.01))
  }
  else{
    return (0)
  }
}


MH_newprop <- function(X0, nsteps, f){
  X <- numeric(nsteps+1) 
  X[1] <- X0
  
  for (i in 2:(nsteps+1)){
    Y <- runif(1, min=2, max=45)
    log_acc <- log(f(Y)) - log(f(X[i-1])) #the proposal densities cancel out as they are the same everywhere 
    
    if (log(runif(1)) <= log_acc){
      X[i] <- Y
    }
    else{X[i] <- X[i-1]}
   }
 X
} 

X0sb <- c(15)

chains_b <- lapply(X0sb, function(x0) mcmc(MH_newprop(x0, nsteps=10000, f=target)))
traceplot(chains_b)


```

**Part c.**\
Your solution begins here.

```{r echo=FALSE}
### Question 1c
target <- function(x) {
  if (x>=2){
    return (exp(-3*(x-2)) + exp(-(x-30)^2) + exp(-((x-20)^2)/0.01))
  }
  else{
    return (0)
  }
}


paralleltemp <- function(num.steps, Ts, sigmas, g) { #taken from chapter 11 problem set 5.1 solution
  M <- length(Ts)
  samples <- matrix(NA, nrow = num.steps, ncol=M)
  
  X <- rep(3, M) #we start at 3 since we know the target has non zero probability here
  
  for (n in 1:num.steps) {
      # we are going to do a x-step
      for (m in 1:M) {
        y <- X[m] + sigmas[m]*rnorm(1)
        alpha <- g(y)^(1/Ts[m]) / g(X[m])^(1/Ts[m]) 
        
        if (runif(1) <= alpha) {
          X[m] <- y
        }
      }
      ### we are going for a swap
      m <- sample(1:(M-1), 1)
      
      num = (g(X[m])^(1/Ts[m+1])*g(X[m+1])^(1/Ts[m]))
      denom = (g(X[m])^(1/Ts[m])*g(X[m+1])^(1/Ts[m+1]))
      
      if (runif(1) <= num/denom) {
        X[c(m, m+1)] = X[c(m+1, m)]
      }
    
    samples[n, ] = X
  }
  
  return(samples)
}

Ts <- c(1,20,100,200,500) #should probably justify this
num.steps <- 10000
sigmas <- c(0.1,0.5,1,2,5)
samples <- paralleltemp(num.steps, Ts, sigmas, g=target)

plot(samples[,1],type="l")
hist(samples[100:num.steps, 1], breaks=100, freq=F) #exactly like it should be

```

```{r echo=FALSE}
### Question 1d

#could compute confidence intervals (but for what???), time each algorithm for large samples, etc. 
#Look into more tests that can be done


```

```{r echo=FALSE}
### Question 1e

#could compute ESS


```

# Code appendix

Rather than re-paste all the code to the appendix, here is a trick which makes the markdown file output all the code (without execution) in the appendix, without any duplication.

Please keep in mind to format the code so that the entire code is clearly visible and does not run into the margins of the pdf version.

```{r ref.label=knitr::all_labels(), echo = T, eval = F}
```

# References
